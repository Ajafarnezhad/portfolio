import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import plotly.io as pio
import numpy as np
import os
import argparse
import logging

# Configure logging for transparency and debugging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
pio.templates.default = "plotly_white"

def load_data(data_path):
    """
    Load the supply chain dataset from a CSV file.
    
    Args:
        data_path (str): Path to the CSV file.
    
    Returns:
        pd.DataFrame: Loaded dataset.
    """
    try:
        df = pd.read_csv(data_path)
        logging.info(f"Loaded dataset from {data_path} ({len(df)} records)")
        required_columns = ['Product type', 'SKU', 'Price', 'Availability', 'Number of products sold',
                           'Revenue generated', 'Stock levels', 'Order quantities', 'Shipping carriers',
                           'Shipping costs', 'Transportation modes', 'Costs', 'Defect rates']
        if not all(col in df.columns for col in required_columns):
            raise ValueError(f"Dataset must contain {required_columns}")
        if df.isnull().sum().any():
            logging.warning("Dataset contains null values; consider preprocessing")
        return df
    except Exception as e:
        logging.error(f"Error loading dataset: {str(e)}")
        raise

def perform_eda(df, output_dir):
    """
    Perform exploratory data analysis and save visualizations.
    
    Args:
        df (pd.DataFrame): Input dataset.
        output_dir (str): Directory to save plots.
    """
    try:
        os.makedirs(output_dir, exist_ok=True)

        # Revenue by SKU
        fig = px.line(df, x='SKU', y='Revenue generated', title='Revenue Generated by SKU')
        fig.update_xaxes(title_text='SKU')
        fig.update_yaxes(title_text='Revenue Generated')
        fig.write(os.path.join(output_dir, 'revenue_by_sku.png'))
        logging.info("Saved revenue by SKU plot")

        # Stock levels by SKU
        fig = px.line(df, x='SKU', y='Stock levels', title='Stock Levels by SKU')
        fig.update_xaxes(title_text='SKU')
        fig.update_yaxes(title_text='Stock Levels')
        fig.write(os.path.join(output_dir, 'stock_levels_by_sku.png'))
        logging.info("Saved stock levels by SKU plot")

        # Order quantity by SKU
        fig = px.bar(df, x='SKU', y='Order quantities', title='Order Quantity by SKU')
        fig.update_xaxes(title_text='SKU')
        fig.update_yaxes(title_text='Order Quantities')
        fig.write(os.path.join(output_dir, 'order_quantity_by_sku.png'))
        logging.info("Saved order quantity by SKU plot")

        # Shipping costs by carrier
        fig = px.bar(df, x='Shipping carriers', y='Shipping costs', title='Shipping Costs by Carrier')
        fig.update_xaxes(title_text='Shipping Carrier')
        fig.update_yaxes(title_text='Shipping Costs')
        fig.write(os.path.join(output_dir, 'shipping_costs_by_carrier.png'))
        logging.info("Saved shipping costs by carrier plot")

        # Cost distribution by transportation mode
        fig = px.pie(df, values='Costs', names='Transportation modes',
                     title='Cost Distribution by Transportation Mode', hole=0.5,
                     color_discrete_sequence=px.colors.qualitative.Pastel)
        fig.write(os.path.join(output_dir, 'cost_by_transportation_mode.png'))
        logging.info("Saved cost by transportation mode plot")

        # Defect rates by product type
        defect_rates_by_product = df.groupby('Product type')['Defect rates'].mean().reset_index()
        fig = px.bar(defect_rates_by_product, x='Product type', y='Defect rates',
                     title='Average Defect Rates by Product Type')
        fig.update_xaxes(title_text='Product Type')
        fig.update_yaxes(title_text='Defect Rates')
        fig.write(os.path.join(output_dir, 'defect_rates_by_product.png'))
        logging.info("Saved defect rates by product type plot")

        # Defect rates by transportation mode
        pivot_table = pd.pivot_table(df, values='Defect rates', index=['Transportation modes'], aggfunc='mean')
        fig = px.pie(values=pivot_table['Defect rates'], names=pivot_table.index,
                     title='Defect Rates by Transportation Mode', hole=0.5,
                     color_discrete_sequence=px.colors.qualitative.Pastel)
        fig.write(os.path.join(output_dir, 'defect_rates_by_transportation.png'))
        logging.info("Saved defect rates by transportation mode plot")

    except Exception as e:
        logging.error(f"Error in EDA: {str(e)}")
        raise

def main(args):
    """
    Main function to handle CLI operations for supply chain analysis.
    
    Args:
        args: Parsed command-line arguments.
    """
    try:
        # Load dataset
        df = load_data(args.data_path)

        if args.mode == 'analyze':
            # Perform EDA
            perform_eda(df, args.output_dir)
            print("ðŸŒŸ Analysis Results:")
            print(f"- Average Revenue per SKU: ${df['Revenue generated'].mean():.2f} "
                  f"(std: ${df['Revenue generated'].std():.2f})")
            high_defect_product = df.groupby('Product type')['Defect rates'].mean().idxmax()
            print(f"âœ… Key Insight: {high_defect_product} has the highest defect rate "
                  f"({df.groupby('Product type')['Defect rates'].mean().max():.2f}%)")

        elif args.mode == 'visualize':
            # Generate visualizations only
            perform_eda(df, args.output_dir)

    except Exception as e:
        logging.error(f"Error in main execution: {str(e)}")
        raise

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Supply Chain Analysis: Optimize operations with Python")
    parser.add_argument('--mode', choices=['analyze', 'visualize'], default='analyze',
                        help="Mode: analyze or visualize")
    parser.add_argument('--data_path', default='supply_chain_data.csv', help="Path to the dataset")
    parser.add_argument('--output_dir', default='./plots', help="Directory to save visualizations")
    args = parser.parse_args()

    main(args)